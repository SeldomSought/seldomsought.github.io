<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Areas of Expertise - SeldomSought</title>
    <meta name="description" content="Our expertise spans brand image, aesthetic orchestration, SEO, AEO, guerrilla marketing, business consulting, copywriting, and email/SMS marketing.">
    <meta name="theme-color" content="#D4AF37"/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --gold: #D4AF37;
            --gold-light: #E8C967;
            --gold-dim: #B8860B;
            --gold-dark: #8B6914;
            --bg: #0A0805;
            --text-primary: #E8DCC8;
            --text-secondary: rgba(212,175,55,0.7);
            --panel-bg: rgba(15,12,8,0.88);
        }
        body {
            font-family: 'Cormorant Garamond', serif;
            color: var(--text-primary);
            background: var(--bg);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Canvases */
        #dragonCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }
        #decorCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* Navigation */
        nav {
            position: fixed; top: 0; width: 100%;
            background: rgba(10,8,5,0.92);
            border-bottom: 1px solid rgba(212,175,55,0.15);
            z-index: 200; backdrop-filter: blur(10px);
        }
        .nav-container {
            max-width: 1200px; margin: 0 auto; padding: 1.2rem 2rem;
            display: flex; justify-content: space-between; align-items: center;
        }
        .logo {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem; color: var(--gold); text-decoration: none;
            text-shadow: 0 0 10px rgba(212,175,55,0.5), 0 0 20px rgba(212,175,55,0.3);
            letter-spacing: 3px;
        }
        .nav-links { display: flex; gap: 2rem; list-style: none; }
        .nav-links a {
            font-family: 'Share Tech Mono', monospace;
            text-decoration: none; color: var(--gold-dark);
            font-size: 0.85rem; letter-spacing: 1px; text-transform: uppercase;
            transition: all 0.3s; position: relative;
        }
        .nav-links a:hover { color: var(--gold); text-shadow: 0 0 8px rgba(212,175,55,0.6); }
        .nav-links a::after {
            content: ''; position: absolute; bottom: -4px; left: 0;
            width: 0; height: 1px; background: var(--gold);
            box-shadow: 0 0 5px var(--gold); transition: width 0.3s;
        }
        .nav-links a:hover::after { width: 100%; }
        .menu-toggle {
            display: none; background: none;
            border: 1px solid var(--gold-dark);
            font-size: 1.5rem; cursor: pointer; color: var(--gold);
            padding: 0.2rem 0.5rem;
        }
        .mobile-menu { display: none; }

        /* Page Header */
        .page-header {
            padding: 8rem 2rem 2rem; text-align: center;
            position: relative; z-index: 10;
        }
        .page-header h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.8rem; margin-bottom: 0.8rem;
            color: var(--gold); font-weight: 600;
            text-shadow: 0 0 20px rgba(212,175,55,0.4), 0 0 40px rgba(212,175,55,0.2);
            letter-spacing: 6px; text-transform: uppercase;
            opacity: 0; transform: translateY(20px);
            animation: headerFadeIn 1.5s ease 3.5s forwards;
        }
        .page-header .subtitle {
            font-family: 'Cormorant Garamond', serif;
            color: var(--text-secondary); font-size: 1.2rem;
            letter-spacing: 3px; font-style: italic;
            opacity: 0; transform: translateY(10px);
            animation: headerFadeIn 1.5s ease 4s forwards;
        }
        @keyframes headerFadeIn {
            to { opacity: 1; transform: translateY(0); }
        }

        /* Expertise Panels (desktop: absolutely positioned along curve) */
        .expertise-panels-container {
            position: relative; z-index: 10;
            width: 100%; min-height: 100vh;
        }
        .expertise-panel {
            position: absolute;
            width: 200px;
            background: var(--panel-bg);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(212,175,55,0.2);
            padding: 1.2rem 1rem;
            text-align: center;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.6s ease, transform 0.6s ease, border-color 0.3s, box-shadow 0.3s;
            cursor: default;
        }
        .expertise-panel.visible {
            opacity: 1; transform: scale(1);
        }
        .expertise-panel:hover {
            border-color: rgba(212,175,55,0.6);
            box-shadow: 0 0 25px rgba(212,175,55,0.15), inset 0 0 15px rgba(212,175,55,0.05);
        }
        .expertise-panel h3 {
            font-family: 'Cinzel', serif;
            font-size: 0.95rem; margin-bottom: 0.4rem;
            color: var(--gold); font-weight: 600;
            letter-spacing: 1px;
        }
        .expertise-panel p {
            font-family: 'Cormorant Garamond', serif;
            color: var(--text-secondary); font-size: 0.95rem;
            letter-spacing: 0.5px; font-style: italic;
        }

        /* Footer */
        footer {
            background: rgba(10,8,5,0.95);
            color: var(--text-secondary);
            padding: 4rem 2.5rem 2.5rem;
            border-top: 1px solid rgba(212,175,55,0.15);
            position: relative; z-index: 10;
            font-family: 'Cormorant Garamond', serif;
        }
        .footer-content {
            max-width: 1200px; margin: 0 auto;
            display: grid; grid-template-columns: 2fr 1fr 1fr;
            gap: 4rem; margin-bottom: 2.5rem;
        }
        .footer-section h3 {
            font-family: 'Cinzel', serif;
            font-size: 1.35rem; margin-bottom: 1.3rem;
            color: var(--gold);
            text-shadow: 0 0 8px rgba(212,175,55,0.3);
            letter-spacing: 2px; text-transform: uppercase; font-weight: 600;
        }
        .footer-section p { color: var(--text-secondary); line-height: 1.7; }
        .footer-links { list-style: none; }
        .footer-links a {
            font-family: 'Share Tech Mono', monospace;
            color: var(--gold-dark); text-decoration: none;
            display: block; padding: 0.4rem 0; transition: all 0.2s;
            letter-spacing: 1px; font-size: 1.1rem;
        }
        .footer-links a:hover {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(212,175,55,0.4);
            padding-left: 0.5rem;
        }
        .footer-links a::before { content: '\u03C6 '; opacity: 0; transition: opacity 0.2s; }
        .footer-links a:hover::before { opacity: 1; }
        .footer-bottom {
            max-width: 1200px; margin: 0 auto; padding-top: 2.5rem;
            border-top: 1px solid rgba(212,175,55,0.1);
            text-align: center; color: rgba(212,175,55,0.3);
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem; letter-spacing: 1px;
        }

        /* Mobile */
        @media (max-width: 768px) {
            .menu-toggle { display: block; }
            .nav-links { display: none; }
            .mobile-menu {
                position: fixed; top: 60px; left: 0; right: 0;
                background: rgba(10,8,5,0.95);
                border-bottom: 1px solid rgba(212,175,55,0.15);
                padding: 1rem 2rem; backdrop-filter: blur(10px);
                z-index: 200;
            }
            .mobile-menu.active { display: block; }
            .mobile-menu ul { list-style: none; }
            .mobile-menu a {
                font-family: 'Share Tech Mono', monospace;
                display: block; padding: 0.8rem 0; text-decoration: none;
                color: var(--gold-dark);
                border-bottom: 1px solid rgba(212,175,55,0.08);
                letter-spacing: 1px; text-transform: uppercase; font-size: 0.85rem;
            }
            .mobile-menu a:hover { color: var(--gold); text-shadow: 0 0 8px rgba(212,175,55,0.4); }
            .page-header h1 { font-size: 2rem; letter-spacing: 3px; }
            .page-header .subtitle { font-size: 1rem; }
            .expertise-panels-container {
                position: relative; min-height: auto;
                padding: 1rem 1rem 2rem;
            }
            .expertise-panel {
                position: relative !important;
                width: 100% !important;
                left: auto !important; top: auto !important;
                margin-bottom: 1rem;
                opacity: 1; transform: scale(1);
            }
            .footer-content { grid-template-columns: 1fr; gap: 2rem; }
        }

        @media (min-width: 1024px) {
            .page-header h1 { font-size: clamp(3.5rem, 4.5vw, 5rem); }
            .nav-container { padding-top: 2rem; padding-bottom: 2rem; }
            .logo { font-size: 2.6rem; }
            .nav-links { gap: 3.25rem; }
            .nav-links a { font-size: 1.3rem; }
            .expertise-panel h3 { font-size: 1.2rem; }
            .expertise-panel p { font-size: 1.05rem; }
            .expertise-panel { padding: 1.8rem 1.5rem; }
        }
    </style>
</head>
<body>
    <canvas id="dragonCanvas"></canvas>
    <canvas id="decorCanvas"></canvas>

    <nav>
        <div class="nav-container">
            <a href="index.html" class="logo">SeldomSought</a>
            <button class="menu-toggle" id="menuToggle">&#9776;</button>
            <ul class="nav-links">
                <li><a href="index.html">Home</a></li>
                <li><a href="philosophy.html">Philosophy</a></li>
                <li><a href="services.html">Services</a></li>
                <li><a href="expertise.html">Expertise</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="faq.html">FAQ</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </div>
        <div class="mobile-menu" id="mobileMenu">
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="philosophy.html">Philosophy</a></li>
                <li><a href="services.html">Services</a></li>
                <li><a href="expertise.html">Expertise</a></li>
                <li><a href="projects.html">Projects</a></li>
                <li><a href="faq.html">FAQ</a></li>
                <li><a href="contact.html">Contact</a></li>
            </ul>
        </div>
    </nav>

    <div class="page-header">
        <h1>Areas of Expertise</h1>
        <p class="subtitle">Where strategy becomes signal</p>
    </div>

    <div class="expertise-panels-container" id="panelsContainer">
        <div class="expertise-panel" data-index="0"><h3>Brand Image</h3><p>Identity, presence, perception</p></div>
        <div class="expertise-panel" data-index="1"><h3>Aesthetic Orchestration</h3><p>Cohesive look, feel, tone</p></div>
        <div class="expertise-panel" data-index="2"><h3>SEO</h3><p>Organic visibility, authority</p></div>
        <div class="expertise-panel" data-index="3"><h3>AEO</h3><p>Answer engine optimization</p></div>
        <div class="expertise-panel" data-index="4"><h3>Guerrilla Marketing</h3><p>Unconventional, high-impact</p></div>
        <div class="expertise-panel" data-index="5"><h3>Marketing Strategy</h3><p>Full-funnel campaign planning</p></div>
        <div class="expertise-panel" data-index="6"><h3>Business Consulting</h3><p>Growth, positioning, direction</p></div>
        <div class="expertise-panel" data-index="7"><h3>Copywriting</h3><p>Words that convert</p></div>
        <div class="expertise-panel" data-index="8"><h3>Email Marketing</h3><p>Sequences, campaigns, lists</p></div>
        <div class="expertise-panel" data-index="9"><h3>SMS Marketing</h3><p>Direct mobile engagement</p></div>
        <div class="expertise-panel" data-index="10"><h3>Competitive Analysis</h3><p>Market gaps, positioning intel</p></div>
        <div class="expertise-panel" data-index="11"><h3>Brand Voice</h3><p>Messaging, tone, narrative</p></div>
    </div>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h3>SeldomSought</h3>
                <p>Brand image, marketing strategy, and business consulting for brands built to stand out.</p>
            </div>
            <div class="footer-section">
                <h3>Navigate</h3>
                <ul class="footer-links">
                    <li><a href="philosophy.html">Philosophy</a></li>
                    <li><a href="services.html">Services</a></li>
                    <li><a href="expertise.html">Expertise</a></li>
                    <li><a href="projects.html">Projects</a></li>
                    <li><a href="faq.html">FAQ</a></li>
                    <li><a href="contact.html">Contact</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h3>Services</h3>
                <ul class="footer-links">
                    <li><a href="services.html">Brand Image</a></li>
                    <li><a href="services.html">SEO &amp; AEO</a></li>
                    <li><a href="services.html">Guerrilla Marketing</a></li>
                    <li><a href="services.html">Copywriting</a></li>
                </ul>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2024 SeldomSought. All rights reserved.</p>
        </div>
    </footer>

    <script>
    (function() {
        'use strict';

        // --- Configuration ---
        const PHI = (1 + Math.sqrt(5)) / 2;
        const isMobile = window.innerWidth < 768;
        const ITERATIONS = isMobile ? 10 : 14;
        const PARTICLE_COUNT = isMobile ? 50 : 250;
        const SPARKLE_COUNT = isMobile ? 20 : 80;
        const DRAW_DURATION = 3500; // ms
        const PANEL_COUNT = 12;
        const CURVE_PADDING = 80;

        // Golden dragon parameters
        const r1 = 1 / Math.sqrt(1 + PHI * PHI);
        const r2 = PHI / Math.sqrt(1 + PHI * PHI);
        const theta1 = Math.atan(PHI);
        const theta2 = Math.PI - Math.atan(1 / PHI);

        // --- Canvas setup ---
        const dragonCanvas = document.getElementById('dragonCanvas');
        const decorCanvas = document.getElementById('decorCanvas');
        const dCtx = dragonCanvas.getContext('2d');
        const decCtx = decorCanvas.getContext('2d');

        let W, H;
        function resizeCanvases() {
            W = window.innerWidth;
            H = window.innerHeight;
            dragonCanvas.width = W; dragonCanvas.height = H;
            decorCanvas.width = W; decorCanvas.height = H;
        }
        resizeCanvases();

        // --- Generate Golden Dragon Curve (IFS) ---
        function generateGoldenDragon(iterations) {
            let segments = [{x0: 0, y0: 0, x1: 1, y1: 0, dir: 1}];

            for (let iter = 0; iter < iterations; iter++) {
                const newSegments = [];
                for (const seg of segments) {
                    const dx = seg.x1 - seg.x0;
                    const dy = seg.y1 - seg.y0;

                    if (seg.dir === 1) {
                        // T1: rotate by theta1, scale by r1
                        const mx = seg.x0 + r1 * (dx * Math.cos(theta1) - dy * Math.sin(theta1));
                        const my = seg.y0 + r1 * (dx * Math.sin(theta1) + dy * Math.cos(theta1));
                        newSegments.push({x0: seg.x0, y0: seg.y0, x1: mx, y1: my, dir: 1});
                        newSegments.push({x0: mx, y0: my, x1: seg.x1, y1: seg.y1, dir: -1});
                    } else {
                        // T2: rotate by -theta2 from end, scale by r2
                        const mx = seg.x1 + r2 * (-dx * Math.cos(theta2) - (-dy) * Math.sin(theta2));
                        const my = seg.y1 + r2 * (-dx * Math.sin(theta2) + (-dy) * Math.cos(theta2));
                        newSegments.push({x0: seg.x0, y0: seg.y0, x1: mx, y1: my, dir: 1});
                        newSegments.push({x0: mx, y0: my, x1: seg.x1, y1: seg.y1, dir: -1});
                    }
                }
                segments = newSegments;
            }

            // Build a polyline from segments
            const polyline = [{x: segments[0].x0, y: segments[0].y0}];
            for (const seg of segments) {
                polyline.push({x: seg.x1, y: seg.y1});
            }
            return polyline;
        }

        let dragonPoints = generateGoldenDragon(ITERATIONS);

        // --- Fit to viewport ---
        function fitToViewport(points) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const p of points) {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }

            const curveW = maxX - minX;
            const curveH = maxY - minY;
            const padX = CURVE_PADDING;
            const padY = CURVE_PADDING + 60; // extra top for nav
            const scaleX = (W - padX * 2) / curveW;
            const scaleY = (H - padY * 2) / curveH;
            const scale = Math.min(scaleX, scaleY);

            const offX = (W - curveW * scale) / 2 - minX * scale;
            const offY = (H - curveH * scale) / 2 - minY * scale + 30;

            const fitted = points.map(p => ({
                x: p.x * scale + offX,
                y: p.y * scale + offY
            }));

            return fitted;
        }

        let fittedPoints = fitToViewport(dragonPoints);

        // --- Compute arc lengths and anchor points ---
        let arcLengths = [];
        let totalArcLength = 0;

        function computeArcLengths() {
            arcLengths = [0];
            totalArcLength = 0;
            for (let i = 1; i < fittedPoints.length; i++) {
                const dx = fittedPoints[i].x - fittedPoints[i-1].x;
                const dy = fittedPoints[i].y - fittedPoints[i-1].y;
                totalArcLength += Math.sqrt(dx * dx + dy * dy);
                arcLengths.push(totalArcLength);
            }
        }
        computeArcLengths();

        // Find point at given arc length fraction
        function pointAtFraction(frac) {
            const targetLen = frac * totalArcLength;
            let lo = 0, hi = arcLengths.length - 1;
            while (lo < hi - 1) {
                const mid = (lo + hi) >> 1;
                if (arcLengths[mid] < targetLen) lo = mid; else hi = mid;
            }
            const segLen = arcLengths[hi] - arcLengths[lo];
            const t = segLen > 0 ? (targetLen - arcLengths[lo]) / segLen : 0;
            return {
                x: fittedPoints[lo].x + t * (fittedPoints[hi].x - fittedPoints[lo].x),
                y: fittedPoints[lo].y + t * (fittedPoints[hi].y - fittedPoints[lo].y),
                segIndex: lo
            };
        }

        // 12 anchors at equal arc-length intervals
        const anchors = [];
        for (let i = 0; i < PANEL_COUNT; i++) {
            const frac = (i + 0.5) / PANEL_COUNT;
            const pt = pointAtFraction(frac);
            const startSeg = Math.floor((i / PANEL_COUNT) * (fittedPoints.length - 1));
            const endSeg = Math.floor(((i + 1) / PANEL_COUNT) * (fittedPoints.length - 1));
            anchors.push({
                x: pt.x, y: pt.y,
                startSeg: startSeg,
                endSeg: endSeg,
                panelX: 0, panelY: 0
            });
        }

        // --- Position panels with collision relaxation ---
        const panels = document.querySelectorAll('.expertise-panel');
        const panelW = 200, panelH = 85;

        function positionPanels() {
            if (isMobile) return;

            // Initial positions: offset from anchor
            for (let i = 0; i < anchors.length; i++) {
                const a = anchors[i];
                // Alternate sides to spread panels
                const angle = (i / anchors.length) * Math.PI * 2 + Math.PI / 4;
                const dist = 120;
                a.panelX = a.x + Math.cos(angle) * dist - panelW / 2;
                a.panelY = a.y + Math.sin(angle) * dist - panelH / 2;
            }

            // Force-directed relaxation
            for (let iter = 0; iter < 100; iter++) {
                for (let i = 0; i < anchors.length; i++) {
                    for (let j = i + 1; j < anchors.length; j++) {
                        const a = anchors[i], b = anchors[j];
                        const cx1 = a.panelX + panelW / 2, cy1 = a.panelY + panelH / 2;
                        const cx2 = b.panelX + panelW / 2, cy2 = b.panelY + panelH / 2;

                        const overlapX = (panelW + 20) - Math.abs(cx1 - cx2);
                        const overlapY = (panelH + 15) - Math.abs(cy1 - cy2);

                        if (overlapX > 0 && overlapY > 0) {
                            const pushX = overlapX / 2 * (cx1 < cx2 ? -1 : 1);
                            const pushY = overlapY / 2 * (cy1 < cy2 ? -1 : 1);

                            if (overlapX < overlapY) {
                                a.panelX += pushX * 0.6;
                                b.panelX -= pushX * 0.6;
                            } else {
                                a.panelY += pushY * 0.6;
                                b.panelY -= pushY * 0.6;
                            }
                        }
                    }

                    // Keep in viewport
                    const a = anchors[i];
                    a.panelX = Math.max(10, Math.min(W - panelW - 10, a.panelX));
                    a.panelY = Math.max(70, Math.min(H - panelH - 10, a.panelY));
                }
            }

            // Apply positions
            panels.forEach((panel, i) => {
                if (i < anchors.length) {
                    panel.style.left = anchors[i].panelX + 'px';
                    panel.style.top = anchors[i].panelY + 'px';
                }
            });
        }

        // Set container height on desktop
        function setContainerHeight() {
            if (isMobile) return;
            const container = document.getElementById('panelsContainer');
            container.style.height = H + 'px';
            container.style.position = 'relative';
        }

        setContainerHeight();
        positionPanels();

        // --- Particles ---
        class Particle {
            constructor() { this.reset(); }
            reset() {
                this.progress = Math.random();
                this.speed = (0.0001 + Math.random() * 0.0003) * (isMobile ? 1.5 : 1);
                this.size = 1 + Math.random() * 2;
                this.alpha = 0.3 + Math.random() * 0.5;
                this.trail = [];
                this.trailMax = 6 + Math.floor(Math.random() * 8);
            }
            update() {
                this.progress += this.speed;
                if (this.progress >= 1) this.reset();

                const pt = pointAtFraction(this.progress);
                this.trail.unshift({x: pt.x, y: pt.y});
                if (this.trail.length > this.trailMax) this.trail.pop();
            }
        }

        const particles = [];
        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle());

        // --- Sparkles ---
        class Sparkle {
            constructor() { this.reset(); }
            reset() {
                const frac = Math.random();
                const pt = pointAtFraction(frac);
                this.x = pt.x + (Math.random() - 0.5) * 40;
                this.y = pt.y + (Math.random() - 0.5) * 40;
                this.life = 0;
                this.maxLife = 40 + Math.random() * 60;
                this.size = 1 + Math.random() * 2.5;
            }
            update() {
                this.life++;
                if (this.life >= this.maxLife) this.reset();
            }
            getAlpha() {
                const t = this.life / this.maxLife;
                return t < 0.3 ? t / 0.3 : (1 - t) / 0.7;
            }
        }

        const sparkles = [];
        for (let i = 0; i < SPARKLE_COUNT; i++) {
            const s = new Sparkle();
            s.life = Math.random() * s.maxLife;
            sparkles.push(s);
        }

        // --- Draw state ---
        let drawProgress = 0;
        let drawStartTime = null;
        let drawComplete = false;
        let hoveredPanel = -1;

        // --- Panel hover ---
        panels.forEach((panel, i) => {
            panel.addEventListener('mouseenter', () => { hoveredPanel = i; });
            panel.addEventListener('mouseleave', () => { hoveredPanel = -1; });
        });

        // --- Decoration canvas (golden spiral + phi grid) ---
        function drawDecoration() {
            decCtx.clearRect(0, 0, W, H);

            // Phi grid lines
            decCtx.strokeStyle = 'rgba(212,175,55,0.04)';
            decCtx.lineWidth = 1;

            // Vertical phi divisions
            const phiPositions = [1/PHI, 1 - 1/PHI, 1/(PHI*PHI), 1 - 1/(PHI*PHI)];
            phiPositions.forEach(f => {
                decCtx.beginPath();
                decCtx.moveTo(f * W, 0);
                decCtx.lineTo(f * W, H);
                decCtx.stroke();

                decCtx.beginPath();
                decCtx.moveTo(0, f * H);
                decCtx.lineTo(W, f * H);
                decCtx.stroke();
            });

            // Golden spiral watermark (very subtle)
            decCtx.strokeStyle = 'rgba(212,175,55,0.03)';
            decCtx.lineWidth = 1.5;
            decCtx.beginPath();
            let spiralX = W * 0.5, spiralY = H * 0.5;
            let spiralR = Math.min(W, H) * 0.3;
            let spiralAngle = 0;

            for (let i = 0; i < 720; i++) {
                const a = (spiralAngle * Math.PI) / 180;
                const r = spiralR * Math.pow(PHI, -spiralAngle / 360);
                const sx = spiralX + r * Math.cos(a);
                const sy = spiralY + r * Math.sin(a);

                if (i === 0) decCtx.moveTo(sx, sy);
                else decCtx.lineTo(sx, sy);

                spiralAngle += 2;
            }
            decCtx.stroke();
        }

        drawDecoration();

        // --- Main render loop ---
        function render(now) {
            requestAnimationFrame(render);

            if (!drawStartTime) drawStartTime = now;
            const elapsed = now - drawStartTime;

            dCtx.clearRect(0, 0, W, H);

            // Progress of draw animation
            if (!drawComplete) {
                drawProgress = Math.min(1, elapsed / DRAW_DURATION);
                if (drawProgress >= 1) {
                    drawComplete = true;
                    showPanelsSequentially();
                }
            }

            const pointsToDraw = Math.floor(drawProgress * fittedPoints.length);

            // --- Draw the dragon curve ---
            // Base curve (dim)
            if (pointsToDraw > 1) {
                dCtx.beginPath();
                dCtx.moveTo(fittedPoints[0].x, fittedPoints[0].y);
                for (let i = 1; i < pointsToDraw; i++) {
                    dCtx.lineTo(fittedPoints[i].x, fittedPoints[i].y);
                }
                dCtx.strokeStyle = 'rgba(184,134,11,0.35)';
                dCtx.lineWidth = 1.5;
                dCtx.stroke();

                // Glow layer
                dCtx.beginPath();
                dCtx.moveTo(fittedPoints[0].x, fittedPoints[0].y);
                for (let i = 1; i < pointsToDraw; i++) {
                    dCtx.lineTo(fittedPoints[i].x, fittedPoints[i].y);
                }
                dCtx.strokeStyle = 'rgba(212,175,55,0.12)';
                dCtx.lineWidth = 4;
                dCtx.stroke();
            }

            // Draw pen head glow during intro
            if (!drawComplete && pointsToDraw > 0 && pointsToDraw < fittedPoints.length) {
                const tip = fittedPoints[pointsToDraw - 1];
                const gradient = dCtx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, 25);
                gradient.addColorStop(0, 'rgba(232,201,103,0.8)');
                gradient.addColorStop(0.3, 'rgba(212,175,55,0.4)');
                gradient.addColorStop(1, 'rgba(212,175,55,0)');
                dCtx.beginPath();
                dCtx.arc(tip.x, tip.y, 25, 0, Math.PI * 2);
                dCtx.fillStyle = gradient;
                dCtx.fill();

                // Bright core
                dCtx.beginPath();
                dCtx.arc(tip.x, tip.y, 3, 0, Math.PI * 2);
                dCtx.fillStyle = '#E8C967';
                dCtx.fill();
            }

            // --- Highlight hovered segment ---
            if (hoveredPanel >= 0 && hoveredPanel < anchors.length && drawComplete) {
                const a = anchors[hoveredPanel];
                dCtx.beginPath();
                const start = Math.max(0, a.startSeg);
                const end = Math.min(fittedPoints.length - 1, a.endSeg);
                if (start < fittedPoints.length) {
                    dCtx.moveTo(fittedPoints[start].x, fittedPoints[start].y);
                    for (let i = start + 1; i <= end; i++) {
                        dCtx.lineTo(fittedPoints[i].x, fittedPoints[i].y);
                    }
                    dCtx.strokeStyle = 'rgba(232,201,103,0.8)';
                    dCtx.lineWidth = 3;
                    dCtx.shadowColor = '#E8C967';
                    dCtx.shadowBlur = 15;
                    dCtx.stroke();
                    dCtx.shadowBlur = 0;
                }
            }

            // --- Connector lines (dashed) from anchor to panel ---
            if (drawComplete && !isMobile) {
                dCtx.setLineDash([4, 6]);
                for (let i = 0; i < anchors.length; i++) {
                    const a = anchors[i];
                    const pcx = a.panelX + panelW / 2;
                    const pcy = a.panelY + panelH / 2;

                    const alpha = hoveredPanel === i ? 0.6 : 0.2;
                    dCtx.beginPath();
                    dCtx.moveTo(a.x, a.y);
                    dCtx.lineTo(pcx, pcy);
                    dCtx.strokeStyle = `rgba(212,175,55,${alpha})`;
                    dCtx.lineWidth = 1;
                    dCtx.stroke();

                    // Small circle at anchor
                    dCtx.beginPath();
                    dCtx.arc(a.x, a.y, 3, 0, Math.PI * 2);
                    dCtx.fillStyle = `rgba(212,175,55,${alpha + 0.2})`;
                    dCtx.fill();
                }
                dCtx.setLineDash([]);
            }

            // --- Particles (after draw completes) ---
            if (drawComplete) {
                for (const p of particles) {
                    p.update();

                    if (p.trail.length > 1) {
                        for (let t = 1; t < p.trail.length; t++) {
                            const trailAlpha = p.alpha * (1 - t / p.trail.length) * 0.6;
                            dCtx.beginPath();
                            dCtx.moveTo(p.trail[t-1].x, p.trail[t-1].y);
                            dCtx.lineTo(p.trail[t].x, p.trail[t].y);
                            dCtx.strokeStyle = `rgba(232,201,103,${trailAlpha})`;
                            dCtx.lineWidth = p.size * (1 - t / p.trail.length);
                            dCtx.stroke();
                        }
                    }

                    if (p.trail.length > 0) {
                        dCtx.beginPath();
                        dCtx.arc(p.trail[0].x, p.trail[0].y, p.size, 0, Math.PI * 2);
                        dCtx.fillStyle = `rgba(232,201,103,${p.alpha})`;
                        dCtx.fill();
                    }
                }

                // --- Sparkles ---
                for (const s of sparkles) {
                    s.update();
                    const a = s.getAlpha() * 0.6;
                    if (a > 0.01) {
                        dCtx.beginPath();
                        dCtx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                        dCtx.fillStyle = `rgba(212,175,55,${a})`;
                        dCtx.fill();
                    }
                }
            }
        }

        requestAnimationFrame(render);

        // --- Show panels after draw ---
        function showPanelsSequentially() {
            if (isMobile) {
                panels.forEach(p => p.classList.add('visible'));
                return;
            }
            panels.forEach((panel, i) => {
                setTimeout(() => panel.classList.add('visible'), i * 100);
            });
        }

        // On mobile, show immediately
        if (isMobile) {
            panels.forEach(p => p.classList.add('visible'));
        }

        // --- Handle resize ---
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvases();
                fittedPoints = fitToViewport(dragonPoints);
                computeArcLengths();

                // Recompute anchors
                for (let i = 0; i < PANEL_COUNT; i++) {
                    const frac = (i + 0.5) / PANEL_COUNT;
                    const pt = pointAtFraction(frac);
                    anchors[i].x = pt.x;
                    anchors[i].y = pt.y;
                    anchors[i].startSeg = Math.floor((i / PANEL_COUNT) * (fittedPoints.length - 1));
                    anchors[i].endSeg = Math.floor(((i + 1) / PANEL_COUNT) * (fittedPoints.length - 1));
                }

                setContainerHeight();
                positionPanels();
                drawDecoration();
            }, 200);
        });

        // --- Mobile menu ---
        const menuToggle = document.getElementById('menuToggle');
        const mobileMenu = document.getElementById('mobileMenu');
        menuToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            mobileMenu.classList.toggle('active');
            menuToggle.innerHTML = mobileMenu.classList.contains('active') ? '&#10005;' : '&#9776;';
        });
        document.addEventListener('click', function(e) {
            if (!e.target.closest('nav')) {
                mobileMenu.classList.remove('active');
                menuToggle.innerHTML = '&#9776;';
            }
        });

    })();
    </script>
</body>
</html>
